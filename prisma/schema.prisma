// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

// Note that some adapters may set a maximum length for the String type by default, please ensure your strings are long
// enough when changing adapters.
// See https://www.prisma.io/docs/orm/reference/prisma-schema-reference#string for more information
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Session {
  id            String    @id
  shop          String
  state         String
  isOnline      Boolean   @default(false)
  scope         String?
  expires       DateTime?
  accessToken   String
  userId        BigInt?
  firstName     String?
  lastName      String?
  email         String?
  accountOwner  Boolean   @default(false)
  locale        String?
  collaborator  Boolean?  @default(false)
  emailVerified Boolean?  @default(false)
}

model Shop {
  id        String   @id @default(cuid())
  domain    String   @unique // The shop's domain, e.g., example.myshopify.com
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  pixelEvents     PixelEvent[]
  pixelSessions   PixelSession[]
  productMetadata ProductMetadata[]
  productViews    ProductView[]
  cartActions     CartAction[]
  orders          Order[]
}

model PixelEvent {
  id        String   @id @default(cuid())
  eventType String
  timestamp DateTime @default(now())
  userAgent String?
  eventData Json // Store the full event payload

  // Denormalized for potential direct queries, not part of a relation itself here
  requestShopDomain   String? // The domain as received in the request
  requestSessionToken String? // The session token as received in the request

  // Relation to Shop model
  shopId String? // Foreign key
  shop   Shop?   @relation(fields: [shopId], references: [id])

  // Relation to PixelSession model
  pixelSessionId String? // Foreign key
  pixelSession   PixelSession? @relation(fields: [pixelSessionId], references: [id])

  productViews ProductView[]
  cartActions  CartAction[]
  orders       Order[]

  @@index([shopId])
  @@index([pixelSessionId])
  @@index([requestSessionToken])
}

model PixelSession {
  id                String   @id @default(cuid())
  shop              Shop?    @relation(fields: [shopId], references: [id])
  shopId            String?
  sessionToken      String // This was from body.id
  clientId          String? // From body.clientId
  userAgent         String?
  requestShopDomain String?
  firstSeen         DateTime @default(now())
  lastActive        DateTime @updatedAt

  // New fields for richer identification
  checkoutToken     String? // From body.data.checkout.token
  customerEmail     String? // From body.data.checkout.email
  shopifyCustomerId String? // From body.data.checkout.order.customer.id
  shopifyOrderId    String? // From body.data.checkout.order.id (available on checkout_completed)

  events       PixelEvent[]
  productViews ProductView[]
  cartActions  CartAction[]
  orders       Order[]

  @@unique([shopId, clientId], name: "shopId_clientId_unique")
  @@index([shopId])
  @@index([sessionToken])
  @@index([clientId])
  @@index([checkoutToken])
  @@index([customerEmail])
  @@index([shopifyCustomerId])
  @@index([shopifyOrderId])
}

model ProductMetadata {
  id               String @id @default(cuid())
  shopifyProductId String @unique // e.g., gid://shopify/Product/12345
  shopId           String
  shop             Shop   @relation(fields: [shopId], references: [id])

  title       String
  handle      String?
  productType String?
  vendor      String?
  tags        String[] @default([])
  status      String? // e.g., ACTIVE, ARCHIVED, DRAFT

  minVariantPrice Float? // Minimum price of its variants
  maxVariantPrice Float? // Maximum price of its variants
  currencyCode    String? // Currency code for the prices

  featuredImageUrl String?

  // For MVP, storing some denormalized variant and collection data as JSON.
  // Can be normalized to separate tables in a later phase if complex querying is needed.
  variantsData    Json? // Array of basic variant info: [{ id, title, price, sku, inventoryQuantity, inventoryPolicy, imageUrl }]
  collectionsData Json? // Array of collection info: [{ id, title, handle }]

  shopifyCreatedAt DateTime? // Product creation date in Shopify
  shopifyUpdatedAt DateTime? // Product last update date in Shopify

  lastFetchedAt      DateTime @default(now()) // When NovaPixel last fetched/updated this data
  pixelNovaUpdatedAt DateTime @updatedAt // When this record was updated in NovaPixel DB

  productViews ProductView[] @relation("ProductMetadataToProductView")
  cartActions  CartAction[]  @relation("ProductMetadataToCartAction")
  orderItems   OrderItem[]   @relation("ProductMetadataToOrderItem")

  @@index([shopId])
  @@index([shopId, productType])
  @@index([shopId, vendor])
  @@index([shopId, status])
}

/// ProductView: Tracks every time a product is viewed
model ProductView {
  id                String           @id @default(cuid())
  shopId            String
  shop              Shop             @relation(fields: [shopId], references: [id])
  productId         String
  product           ProductMetadata? @relation("ProductMetadataToProductView", fields: [productId], references: [shopifyProductId])
  variantId         String?
  viewedAt          DateTime         @default(now())
  pixelSessionId    String?
  pixelSession      PixelSession?    @relation(fields: [pixelSessionId], references: [id])
  clientId          String?
  checkoutToken     String?
  shopifyCustomerId String?
  eventId           String?
  pixelEvent        PixelEvent?      @relation(fields: [eventId], references: [id])

  @@index([shopId])
  @@index([productId])
  @@index([clientId])
  @@index([checkoutToken])
  @@index([shopifyCustomerId])
}

/// CartAction: Tracks add/remove/update cart actions
model CartAction {
  id                String           @id @default(cuid())
  shopId            String
  shop              Shop             @relation(fields: [shopId], references: [id])
  productId         String
  product           ProductMetadata? @relation("ProductMetadataToCartAction", fields: [productId], references: [shopifyProductId])
  variantId         String?
  actionType        String
  quantity          Int
  timestamp         DateTime         @default(now())
  pixelSessionId    String?
  pixelSession      PixelSession?    @relation(fields: [pixelSessionId], references: [id])
  clientId          String
  checkoutToken     String?
  shopifyCustomerId String?
  eventId           String?
  pixelEvent        PixelEvent?      @relation(fields: [eventId], references: [id])

  @@index([shopId])
  @@index([productId])
  @@index([clientId])
  @@index([checkoutToken])
  @@index([shopifyCustomerId])
}

/// Order: Tracks completed checkouts
model Order {
  id                String        @id @default(cuid())
  shopId            String
  shop              Shop          @relation(fields: [shopId], references: [id])
  shopifyOrderId    String?
  pixelSessionId    String?
  pixelSession      PixelSession? @relation(fields: [pixelSessionId], references: [id])
  clientId          String
  checkoutToken     String?
  shopifyCustomerId String?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @default(now()) @updatedAt
  eventId           String?
  pixelEvent        PixelEvent?   @relation(fields: [eventId], references: [id])
  orderItems        OrderItem[]

  @@index([shopId])
  @@index([shopifyOrderId])
  @@index([clientId])
  @@index([checkoutToken])
  @@index([shopifyCustomerId])
}

/// OrderItem: Line items for each order
model OrderItem {
  id        String           @id @default(cuid())
  orderId   String
  order     Order            @relation(fields: [orderId], references: [id])
  productId String
  product   ProductMetadata? @relation("ProductMetadataToOrderItem", fields: [productId], references: [shopifyProductId])
  variantId String?
  quantity  Int
  price     Float

  @@index([orderId])
  @@index([productId])
}

model UserProfile {
  id                String   @id @default(cuid())
  userId            String
  shopDomain        String
  preferredCategories String[]
  preferredTags     String[]
  preferredBrands   String[]
  preferredPriceMin Float?
  preferredPriceMax Float?
  lastUpdated       DateTime @default(now())

  @@unique([userId, shopDomain])
  @@index([shopDomain])
}

model ProductCooccurrence {
  id                String   @id @default(cuid())
  shopId            String
  productId         String
  coViewedProductId String
  score             Float
  lastUpdated       DateTime @default(now())

  @@index([shopId, productId])
  @@index([shopId, coViewedProductId])
  @@unique([shopId, productId, coViewedProductId])
}

model FrequentlyBoughtTogether {
  id                  String   @id @default(cuid())
  shopId              String
  productId           String
  boughtWithProductId String
  score               Float
  lastUpdated         DateTime @default(now())

  @@index([shopId, productId])
  @@index([shopId, boughtWithProductId])
}

model PopularProduct {
  id          String   @id @default(cuid())
  shopId      String
  productId   String
  score       Float
  lastUpdated DateTime @default(now())

  @@index([shopId])
  @@unique([shopId, productId])
}

model ProductRecommendation {
  id                   String   @id @default(cuid())
  shopDomain           String
  sourceProductId      String
  recommendedProductId String
  recommendationType   String
  score                Float
  lastCalculated       DateTime @default(now())

  @@unique([sourceProductId, recommendedProductId, recommendationType])
  @@index([shopDomain])
}
